Introduction:
    ES6:
    -> ES5 / ES2015 (ES6) 
        ES6 is also refered as ES2015 (ES5 + Awesom features).
    TypeScript:
    -> It is a super set of Javascript which complies the .ts files to .js files.

Transpilers: ctrl+shft B (Select watch:tsconfig.json to run the Transpilers which converts .ts to .js files)
    In Transpilers ES2015 will Transpile (using Traceur / Babel / Typescript) to ES5 to run in all the browsers

Commands:
    => npm install typescript -g (It will install typescript modules globally)
    => npm install lite-server -g (It's server which can run the application on the port number to run)
    => lite-server (This will run and opens a default port number 3000)
    => tsc --init (It will create tsconfig.json file)
    => ctrl+shft B (Select watch:tsconfig.json to run the Transpilers which converts .ts to .js files)

var:
    => It is functional scope. If we declare & use the var variable outside or insde the if, for, switch functions ..etc..,.
    => We can redeclare the same var variable (duplicate var variables) with in the same scope
    => Can initialize the var variable any where in the function scope (Its hoistlie)
let
    => It's a scope decleration, We should declare let varable global level to access inside or outside the block fucntions.
    => we cannot redeclare the same let variable (duplicate let variables) with in the same scope   
    => Should initialize the let variable at the starting of the function scope (Its not hoistlie)
Ex: var & let:
    var a = 1;
    var b = 2;
    if(a === 1){
        var a = 10; // Here it will change var a =1 to 10  
        let b = 20; // Here b is the new let variable which is different from var b = 1 
        console.log(a); // Print 10
        console.log(b); // Print 20 from let b=20 
    }
    console.log(a); // Print 10 from var a = 10 inside the if condition
    console.log(b); // Print 2 from var b=2 declared before if condition.
Const:
    => Its a readonly variable
    => Its a block scoped
    => Must initialize the value
    => If we create an object with `const` we cannot reassign the object(Throws error). But we cann re-assign the property for an object
     Ex: const obj1{
         name:'prcv'
     }
     obj1 = {} // Throws error
     obj1.name = 'Reddy' // name property value is replaced.


Arrow Functions:
    => it a simplified version of javascript function.
    Ex: Javascript function
        var getMsg =function(m){
            return 10*m;
        }
        Arrow Function:
        const getMsg = (m) => 10*m; // Here it will return 10 * m.
        (or)
        const getMsg = m => 10*m; // Here it will return 10.
        const getMsg = (m, bonus) => 10*m+bonus; // Here it will return 10*m+bonus.

lexical 'this' Keyword:
    => this keyword always carry the value of that current function. 
    Ex: In Javascript:
        var employee = {
            id : 1,
            geet : function() {
                var self = this; // Here are assigning `this` to self var varble to access this inside other functions
                setTimeout(function(){console.log(self.id)},1000) // Here we are using self instead of this. because this can have setTimeout function scope. so we using self variable.
            }
        }
    Other way apprach using Arrow Functions:
    var employee = {
            id : 1,
            geet : function() {
                setTimeout(() => {console.log(this.id)},1000) // Here we are using `this` directly
            }
        }

Rest Operators:
    => It takes variable number of arguments and puts them in to single array.
    -> It Specify's in the function decleration.
        Ex: 
            let displayColors = function(message, ...colors){
                console.log(message); // It will display string message value.
                console.log(colors); // It will display all the of arguments as array object
                for(let i in colors) {
                    console.log(colors[i]); // It will display each value in the array object.
                }
            }

            let message = "List of Colors using Rest Operator: "
            displayColors(message,'Red');
            displayColors(message,'Red','Blue');
            displayColors(message,'Red','Blue','Green');



Spread Operator:
    => It is opposite to Rest Operator, It will split the array of arguments and splits it into individual elements.
    => It Specify's in function call.
        Ex: 
             let displayColors = function(message, ...colors){ // Here again ...colors will form it as an array object
                console.log(message); // It will display string message value.
                
                for(let i in colors) {
                    console.log(colors[i]); // It will display each value in the array object.
                }
            }

            let message = "List of Colors using Spread Operator: ";
            let colorArray = ['Green', 'Blue', 'Yellow'];
            displayColors(message, ...colorArray); // Here it will split the array in to individual variables.

Object Literals:
    => Usually will create an object with key value pairs. In ES6 we have shot hand method like:
        Ex: Old method
                let firstName = "John"
                let lastName = "Doe"
                let person = { // Here we are giving Key Value pairs for firstName and  lastName.
                    firstName : firstName, 
                    lastName : lastName
                }
                console.log(person.firstName);
                console.log(person.lastName);
        Ex: New ES6 syntax:
                let firstName = "John"
                let lastName = "Doe"
                let person = { // Here no need to giving Key Value pairs if the both key and value names are same for firstName and  lastName.
                    firstName  , 
                    lastName
                }
                console.log(person.firstName);
                console.log(person.lastName);
        Ex: New ES6 with function return:
                function createPerson(firstName: string, lastName: string, age: number) {
                    let fullName = firstName + " " + lastName;
                    return {
                        firstName,
                        lastName,
                        fullName,
                        isSenior() { // This is the new syntax in ES6
                            return age > 60;
                        },
                        isSeniorfunc: function () { // This is the old syntax
                            return age > 60;
                        }
                    };
                }
                let p = createPerson("John", "Smith", 62);
                console.log("Object Literals using Function return statements: ")
                console.log(p.firstName)
                console.log(p.lastName)
                console.log(p.fullName)
                console.log(p.isSenior())
                console.log(p.isSeniorfunc())
        => In Object Literals we can have spaces in the property names:
            Ex: let ln = "last Name";
                let person = {
                    "fist Name": "John",
                    [ln] : "Doe"
                }
                console.log(person); // It will print person object {"first Name": John, "last Name":Deo};
                console.log(person["first Name"]); // It will print   `John`;

Destructuring Array: 
        => Here, we are assigning the values of array to individual variables in ES6
            Ex: 
                let employee =["John", "Doe"]
                let [fname, lname, gender] = employee;

                console.log(fname);//  It will print `John`
                console.log(lname);//  It will print `Deo`
                console.log(fname);//  It will print `undefined` because we are not passing gender information in 3rd parameter.
        => We can Destructuring the necessary value in the array
            Ex: 
                let employee =["John", "Doe","Male"]
                let [, , gender] = employee; // Here jsut pass an empty space in 1st and 2nd arguments. we are using only Gender information from array.

                console.log(gender);//  It will print `Male`
        => We can Destructuring the array in to single argument and list of array elements also using Rest Operator:
            Ex:
                let employee =["John", "Doe","Male","Married"]
                let [fname, ...elements] = employee;

                console.log(fname);
                console.log(elements); // It will print the array object with ["Doe","Male","Married"]
        => We can Destructuring with default values
            Ex:
                 let employee =["John", "Doe"]

                let [fname, lname, gender = "Male"] = employee;

                console.log(fname);//  It will print `John`
                console.log(lname);//  It will print `Deo`
                console.log(fname);//  It will print `Male`

Destructuring Object: 
        => In ES6 we can create alias name if the property name are big to use mutiple places
            Ex:
                let employee ={
                  fname: "John",lname: "Doe",gender: "Male"
                }
                let {fname :f,lname : l,gender: g} = employee; // Createing alias names.
                console.log(f);//  It will print `John`
                console.log(l);//  It will print `Doe`
                console.log(g);//  It will print `Male`

String Templates:
        => We can concatinate the string with + symbol. But in ES6, we use ${} syntax.
        => It will support multi line string concatination when using back ticks `
            Ex:
                let user = "Prasanth"

                let greet = `Welcome 'single' "double" ${user} to ES6 Tutorial.
                    This is Second line.
                `;
                console.log(greet);// It will print ` Welcome Prasanth to ES6 Tutorial 


for of Loop:
    Ex: 
        let colors = ["Red", "Green", "Blue"];

        //Fist way usin `in`
        for (let i in colors) {
            console.log(colors[i]); // It will display each value in the array object using index position.
        }

        // Second way using `of`
        for (let color of colors) {
            console.log(color); //  It will display each value in the array object without index position.
        }

        let letter ="ABCDEF"
        for(let lett of letter) {
            console.log(letter); 
        }

Classes in ES6:
        =>  Classes are just a special functions, but only different is Classes and Unlike functions are not hoisted.
            Ex: 
                class Person {

                }
                let p = new Person();
                console.log(typeof Person); // It will Print `function`
        => Adding method to  the class is same as adding method to the prototype object.
            Ex: 
                class Person {
                    greetings(){

                    }
                }
                console.log(p.greetings === Person.prototype.greetings); // It will Print `true`

Class Body and Methods:

            Ex:
                class Person {
                    constructor(name){
                        this.name = name;
                        console.log(this.name +" Constructor"); // It will Print
                    }
                    staticMethod(){
                        console.log("Hello PRCV Static Methods")
                    }
                    greetPerson(){
                        console.log(" From Prototype Method : Hello "+ this.name)
                    }
                }
                let p = new Person("PRCV") // Constructor Method:  Here it will call directly constructor of the class Person
                Person.staticMethod(); // Static Method: Here we can call the staticMethod using directly with class name Person instead of p.staticMethod()
                p.greetPerson(); // Prototype Method: Which can call each object.

Class Inheritance:
        => In ES6, Class Inheritance is possible using `extends` keyword.
        => `Exenteds` keyword is used to create a new class that inhertits Parent class.
            Ex: Constructor in Parent class
                class Person {
                    constructor() {
                        console.log("Person class Constructor")
                    }
                }               
                class Employee  extends Person{
                }
                let e= new Employee(); // It prints `Person class Constructor`from Person class constructor.
            Ex: Parameter Constructor in Parent class
                class Person1 {
                    constructor(name ) {
                        console.log(name + " Person class Constructor")
                    }
                }
                class Employee1  extends Person1{
                }
                 let e= new Employee1("PRCV"); // It will print `PRCV Person class Constructor` It will invoke Person1 class parameter constructor even if the Employee1 class doent have parameter constructor.
Constructor in derived class:
        => To create constructor in derived class, need to use super() call
        => super() keyword is, Parent class constructor needs to call before the sub class constructor. This ensure if we call any method on the Parent class in the constructor, 
            the parent is already successfully setup.
            Ex: 
                class Person1 {
                    constructor(name ) {
                        console.log(name + " Person1 class Constructor")
                    }
                    getID(){
                        return 10;
                    }
                }
                class Employee1  extends Person1 {
                    constructor(name) {
                        super(name); // Here it will invoke the constructor of the parent class
                        console.log(name + " Employee1 class Constructor")
                    }
                    
                }
                 class Employee2  extends Person1 {
                    constructor(name) {
                        super(name); // Here it will invoke the constructor of the parent class
                        console.log(name + " Employee1 class Constructor")
                    }
                    getID(){
                        return 10;
                    }
                }
                let e= new Employee1("PRCV");
                console.log(e.getID());// Here we are calling getID mentod which is there in Person1 (parent) class using Employee1 (derived) class object `e.getID()` 
                let e1 = new Employee2("PRCV");
                console.log(e1.getID());// Here we are calling getID  fro,m Employee1 (derived) class object `e.getID()` 
            Output:
                PRCV Person1 class Construct
                PRCV Employee1 class Construct
                10

                PRCV Person1 class Construct
                PRCV Employee1 class Construct
                50
        => Suppose if we  want to access the Parent class getID method. we need to use super() method.
            Ex:
                class Person1 {
                    constructor(name ) {
                        console.log(name + " Person1 class Constructor")
                    }
                    getID(){
                        return 10;
                    }
                }
                class Employee2  extends Person1 {
                    constructor(name) {
                        super(name); // Here it will invoke the constructor of the parent class
                        console.log(name + " Employee1 class Constructor")
                    }
                    getID(){
                        return super.getID(); // Calling Parent class getID method using super keyword.
                    }
                }
                let e1 = new Employee2("PRCV");
                console.log(e1.getID());
            Output:
                PRCV Person1 class Construct
                PRCV Employee1 class Construct
                10


Modules: 
        => In ES6, we can create multiple modules and export / import them in different classes.
        => Modules are  divided the progrma that section of code in to Moduel.
